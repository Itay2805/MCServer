from ctypes import *
from datetime import datetime
import os.path as path
import urllib.request
import json

# TODO: switch to using go:generate

# This has all of the data we need
import stringcase

enums = {
    # 4-way facing
    (
        "north",
        "south",
        "west",
        "east"
    ): {
        'type': 'minecraft.Face',
        'to_meta': 'meta += uint16({value}) - 2',
        'from_meta': '{name} = minecraft.Face((meta % 4) + 2)'
    },

    # 6-way facing
    # (
    #     "north",
    #     "south",
    #     "west",
    #     "east"
    # ): {
    #     'type': 'minecraft.Face',
    #     'to_meta': 'meta += int({value}) - 2',
    #     'from_meta': 'minecraft.Face((meta % 4) + 2)'
    # },

    # A shape
    (
        "straight",
        "inner_left",
        "inner_right",
        "outer_left",
        "outer_right"
    ): {
        'type': 'minecraft.Shape',
    },

    # 2-way face (top bottom)
    (
        "top",
        "bottom"
    ): {
        'type': 'minecraft.Face',
    },

    # Same as above
    (
        "upper",
        "lower"
    ): {
        'type': 'Half',
    },

    # left-right directions
    (
        "left",
        "right"
    ): {
        'type': 'Hinge',
    }
}

# The meta generation
metas = [
    # Used for any stair kind
    {
        'name': 'StairsMeta',
        'states': [
            {
                "name": "facing",
                "type": "enum",
                "num_values": 4,
                "values": [
                    "north",
                    "south",
                    "west",
                    "east"
                ]
            },
            {
                "name": "half",
                "type": "enum",
                "num_values": 2,
                "values": [
                    "top",
                    "bottom"
                ]
            },
            {
                "name": "shape",
                "type": "enum",
                "num_values": 5,
                "values": [
                    "straight",
                    "inner_left",
                    "inner_right",
                    "outer_left",
                    "outer_right"
                ]
            },
            {
                "name": "waterlogged",
                "type": "bool",
                "num_values": 2
            }
        ]
    },

    {
        'name': 'FurnaceMeta',
        "states": [
            {
                "name": "facing",
                "type": "enum",
                "num_values": 4,
                "values": [
                    "north",
                    "south",
                    "west",
                    "east"
                ]
            },
            {
                "name": "lit",
                "type": "bool",
                "num_values": 2
            }
        ],
    },

    # {
    #     'name': 'BarrelMeta',
    #     "states": [
    #         {
    #             "name": "facing",
    #             "type": "enum",
    #             "num_values": 6,
    #             "values": [
    #                 "north",
    #                 "east",
    #                 "south",
    #                 "west",
    #                 "up",
    #                 "down"
    #             ]
    #         },
    #         {
    #             "name": "open",
    #             "type": "bool",
    #             "num_values": 2
    #         }
    #     ],
    # }
]

print("// Code generated by scripts/generate_meta.go; DO NOT EDIT.")
print("// This file was generated by robots at")
print("// " + str(datetime.now()))
print()

print("package block")
print()

for meta in metas:
    name = stringcase.pascalcase(meta['name'])
    print(f'type {name} struct {{')
    for state in meta['states']:
        nam = stringcase.pascalcase(state['name'])
        typ = state['type']
        if typ == 'int':
            print(f'\t{nam} int')
        elif typ == 'enum':
            print(f'\t{nam} {enums[tuple(state["values"])]["type"]}')
        elif typ == 'bool':
            print(f'\t{nam} bool')
    print('}')
    print()

    print(f'func (m *{name}) FromMeta(meta uint16) {{')
    for state in reversed(meta['states']):
        nam = stringcase.pascalcase(state['name'])
        if 'enum' == state['type']:
            n = enums[tuple(state["values"])]
            if 'from_meta' in n:
                print('\t' + n["from_meta"].format(name=f"m.{nam}"))
            else:
                print(f'\tm.{nam} = {n["type"]}(meta % {state["num_values"]})')
        elif 'bool' == state['type']:
            print(f'\tm.{nam} = (meta % 2) == 1')
        else:
            print(f'\tm.{nam} = meta % {state["num_values"]}')
        print(f'\tmeta /= {state["num_values"]}')
    print('}')
    print()

    print(f'func (m *{name}) ToMeta() uint16 {{')
    print('\tmeta := uint16(0)')
    for state in meta['states']:
        nam = stringcase.pascalcase(state['name'])
        print(f'\tmeta *= {state["num_values"]}')
        if 'enum' == state['type']:
            n = enums[tuple(state["values"])]
            if 'to_meta' in n:
                print('\t' + n["to_meta"].format(value=f"m.{nam}"))
            else:
                print(f'\tmeta += uint16(m.{nam})')
        elif 'bool' == state['type']:
            print(f'\tmeta += boolToMeta(m.{nam})')
        else:
            print(f'\tmeta += m.{nam}')
    print('\treturn meta')
    print('}')
    print()
print()
